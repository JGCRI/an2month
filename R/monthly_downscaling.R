
# NEED TO BE CAREFUl about the intermeidate inputs using up too much memory!
# NEED TO DOCUMENT! this needs to be better documented and cleaned up quite a bi!
# see all of the TODOs also there are some sections of code that I did not add

#' @param frac TBD
#' @param fld TBD
#' @param fld_coordinates TDB
#' @param fld_time TBD
#' @param var
#' @import dplyr
#' @return TBD
#' @export

monthly_downscaling <- function(frac, fld, fld_coordinates, fld_time, var){

  # Check the inputs
  # TODO add a check columns function??
  req_lists <- c(var, 'coordinates', 'time')
  missing   <- !req_lists %in% names(frac)
  if(any(missing)) stop('frac is missing ', paste(req_lists[missing], collapse = ', '))

  req_lists <- c(var)
  missing   <- !req_lists %in% names(fld)
  if(any(missing)) stop('flds is missing ', paste(req_lists[missing], collapse = ', '))

  # Ensure that the fractino and fld coordinates are consistent with one another, if NA grid cells are droped
  # during the field generation or different resolutions of netcdf data are used there might be problems.
  if(any(dim(frac$coordinates) < dim(fld_coordinates))) stop('resolution of the monthly fraction is insufficient')

  if(any(dim(frac$coordinates) > dim(fld_coordinates))){

    fld_coordinates %>%
      rename(flds_column_index = column_index) %>%
      left_join(frac$coordinates %>%
                  rename(frac_index = column_index),
                by = c('lat', 'lon')) ->
      lat_lon_mapping

    # Modify the fraction object so that it contains the correct grid cells.
    frac[[var]] <-  frac[[var]][ , lat_lon_mapping$frac_index]

    lat_lon_mapping %>%
      select(index = flds_column_index, lat, lon) ->
      coordinates

  } else {

    # TODO add some code that will check the lat and lon match up??
    # The coordinates are unchanged
    coordinates <- fld_coordinates

  }

  # Now that we know that the grid cells in the data frames represent the same thing we can start the temporal downscaling.
  # Replicate the data frame 12 times, so that there is a copy of the grid cells for each month.
  fld     <- fld[[var]]
  yr_fld  <- nrow(fld)
  fld_12  <- replicate(n = 12, fld, simplify = FALSE)

  # Duplicate the monthly fractions for the number of years in the fields generated by the fldgen
  frac_12 <- lapply(1:nrow(frac[[var]]), function(row){

    do.call("rbind", replicate(n = yr_fld, frac[[var]][row, ], simplify = FALSE))

  })


  # Create an empty list to store monthly values in
  monthly_12 <- list()

  # Mulitply the annual data by each monthly fraction
  for(i in 1:12){

    data <- as.matrix(fld_12[[i]]) * frac_12[[i]]

    # Split into a list so that each list contains data for one month and one year
    # then name the elements of the list accordingly.
    monthly_data <- split(data, row(data))
    names(monthly_data) <- paste0(fld_time, frac$time$month[i])

    monthly_12[[i]] <- monthly_data

  }

  # Fromat into a flat list ordered by yearmonth.
  monthly       <- purrr::flatten(monthly_12)
  ordered_names <- as.character(sort(as.integer(names(monthly))))
  monthly       <- monthly[ordered_names]


  # Clean up intermediate inputs
  remove(monthly_12, frac_12, fld, frac)


  # Convert for different units
  if(var == 'tas'){

    # Convert from K to C using the conversion function
    monthly_converted <- lapply(monthly, tas_conversion)
    unit_value <- 'C'

  } else if (var == 'pr'){

    # Convert from kg/m2*s to mm/month
    monthly_converted <- pr_conversion(monthly)
    unit_value <- 'mm_month-1'

  } else {

    stop('unkown variable, need to add appropriate function')

  }


  list(data = monthly_converted, coordinates = coordinates, units = unit_value)

}
