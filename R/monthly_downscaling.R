
# NEED TO BE CAREFUl about the intermeidate inputs using up too much memory!
# NEED TO DOCUMENT!

#' @param frac_path TBD
#' @param flds_path TBD
#' @param var TBD
#' @import dplyr
#' @return TBD
#' @export

monthly_downscaling <- function(frac_path, flds_path, var){

  # Import the fraction data and emulator output
  frac_object <- get(load(frac_path)) # TODO this should probably be a system.file call
  flds_object <- readRDS(flds_path)

  # First we want to check to see that the coordinates are the same.
  if(any(dim(frac_object$coordinates) != dim(flds_object$coordinates))) stop('resolution of the monthly fractions and the emulator output are different')

  # Then we check to make sure that the lat and lon are the same for the column indices
  rename(frac_object$coordinates, frac_lat = lat, frac_lon = lon) %>%
    left_join(rename(flds_object$coordinates, flds_lat = lat, flds_lon = lon),
              by = "column_index") ->
    coordinates

  if(any(coordinates$frac_lat != coordinates$flds_lat)) stop('problem with the lat')
  if(any(coordinates$frac_lon != coordinates$flds_lon)) stop('problem with the lon')


  # Now that we know that the grid cells in the data frames represent the same thing we can start the temporal downscaling.
  # Replicate the data frame 12 times, so that there is a copy of the grid cells for each month.
  fld     <- flds_object$fullgrids[[1]][[var]]
  yr_fld  <- nrow(fld)
  fld_12 <- replicate(n = 12, fld, simplify = FALSE)

  # Duplicate the monthly fractions for the number of years in the fields generated by the fldgen
  frac_12 <- lapply(1:nrow(frac_object[[var]]), function(row){

    do.call("rbind", replicate(n = yr_fld, frac_object[[var]][row, ], simplify = FALSE))

    })


  # Create an empty list to store monthly values in
  monthly_12 <- list()

  # Mulitply the annual data by each monthly fraction
  for(i in 1:12){

    data <- as.matrix(fld_12[[i]]) * frac_12[[i]]

    # Split into a list so that each list contains data for one month and one year
    # then name the elements of the list accordingly.
    monthly_data <- split(data, row(data))
    names(monthly_data) <- paste0(flds_object$time, frac_object$time$month[i])

    monthly_12[[i]] <- monthly_data

  }

  # Fromat into a flat list ordered by yearmonth.
  monthly       <- purrr::flatten(monthly_12)
  ordered_names <- as.character(sort(as.integer(names(monthly))))
  monthly       <- monthly[ordered_names]

  monthly

  # Clean up intermediate inputs
  remove(monthly_12, frac_12, flds_object, frac_object)


  # Convert for different units
  if(var == 'tas'){

    # Convert from K to C using the conversion function
    monthly_converted <- lapply(monthly, tas_conversion)
    unit_value <- 'C'

  } else if (var == 'pr'){

    # Convert from kg/m2*s to mm/month
    monthly_converted <- pr_conversion(monthly)
    unit_value <- 'mm/month'

  } else {

    stop('unkown variable, need to add appropriate function')

  }

  # Format output
  coordinates <- select(coordinates, index = column_index,
                        lat = frac_lat, lon = frac_lon)

  list(data = monthly, coordinates = coordinates, units = unit_value)

}





